use oasis_std::{
    abi::EndpointInterface,
    types::{Address, U256},
};
use owasm_abi_derive::eth_abi;

#[eth_abi(TestEndpoint, Client)]
pub trait TestContract {
    fn constructor(&mut self, _p: bool);

    fn baz(&mut self, _p1: u32, _p2: bool);
    fn boo(&mut self, _arg: u32) -> u32;
    fn sam(&mut self, _p1: Vec<u8>, _p2: bool, _p3: Vec<U256>);

    #[event]
    fn baz_fired(&mut self, indexed_p1: u32, p2: u32);
}

const PAYLOAD_SAMPLE_1: &[u8] = &[
    0xcd, 0xcd, 0x77, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x45, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01,
];

const PAYLOAD_SAMPLE_2: &[u8] = &[
    0xa5, 0x64, 0x3b, 0xf2, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0xa0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x04, 0x64, 0x61, 0x76, 0x65, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x03,
];

const PAYLOAD_SAMPLE_3: &[u8] = &[
    0x5d, 0xda, 0xb4, 0xd4, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x45,
];

#[test]
fn baz_dispatch() {
    #[derive(Default)]
    struct TestContractInstance {
        called: bool,
        called_wrong: bool,
    }

    impl TestContract for TestContractInstance {
        fn constructor(&mut self, _p1: bool) {}
        fn baz(&mut self, p1: u32, p2: bool) {
            assert_eq!(p1, 69);
            assert_eq!(p2, true);
            self.called = true;
        }
        fn boo(&mut self, _arg: u32) -> u32 {
            self.called_wrong = true;
            0
        }
        fn sam(&mut self, _p1: Vec<u8>, _p2: bool, _p3: Vec<U256>) {
            self.called_wrong = true;
        }
    }

    let mut endpoint = TestEndpoint::new(TestContractInstance::default());
    let result = endpoint.dispatch(PAYLOAD_SAMPLE_1);

    assert_eq!(result, Vec::new());

    assert!(endpoint.inner.called, "`baz` method was not invoked");
    assert!(!endpoint.inner.called_wrong, "wrong method was invoked");
}

#[test]
fn sam_dispatch() {
    #[derive(Default)]
    struct TestContractInstance {
        called: bool,
        called_wrong: bool,
    }

    impl TestContract for TestContractInstance {
        fn constructor(&mut self, _p1: bool) {}
        fn sam(&mut self, p1: Vec<u8>, p2: bool, p3: Vec<U256>) {
            assert_eq!(p1, vec![100, 97, 118, 101]);
            assert_eq!(p2, true);
            assert_eq!(p3, vec![U256::from(1), U256::from(2), U256::from(3),]);
            self.called = true;
        }
        fn baz(&mut self, _p1: u32, _p2: bool) {
            self.called_wrong = true;
        }
        fn boo(&mut self, _arg: u32) -> u32 {
            self.called_wrong = true;
            0
        }
    }

    let mut endpoint = TestEndpoint::new(TestContractInstance::default());
    let result = endpoint.dispatch(PAYLOAD_SAMPLE_2);

    assert_eq!(result, Vec::new());

    assert!(endpoint.inner.called, "`sam` method was not invoked");
    assert!(!endpoint.inner.called_wrong, "wrong method was invoked");
}

#[test]
fn boo_dispatch() {
    #[derive(Default)]
    struct TestContractInstance {
        called: bool,
        called_wrong: bool,
    }

    impl TestContract for TestContractInstance {
        fn constructor(&mut self, _p1: bool) {}
        fn sam(&mut self, _p1: Vec<u8>, _p2: bool, _p3: Vec<U256>) {
            self.called_wrong = true;
        }
        fn baz(&mut self, _p1: u32, _p2: bool) {
            self.called_wrong = true;
        }
        fn boo(&mut self, arg: u32) -> u32 {
            self.called = true;
            assert_eq!(arg, 69);
            255
        }
    }

    let mut endpoint = TestEndpoint::new(TestContractInstance::default());
    let result = endpoint.dispatch(PAYLOAD_SAMPLE_3);

    assert_eq!(&result[28..32], &[0x00, 0x00, 0x00, 0xff]);

    assert!(endpoint.inner.called, "`boo` method was not invoked");
    assert!(!endpoint.inner.called_wrong, "wrong method was invoked");
}

#[allow(dead_code)]
mod contract {
    use owasm_abi_derive::eth_abi;

    #[eth_abi(EmptyEndpoint, _EmptyClient)]
    trait EmptyContract {
        fn constructor(&mut self, _p: bool);
    }

    pub struct EmptyContractInstance {
        pub called: bool,
        pub p: bool,
    }

    impl EmptyContract for EmptyContractInstance {
        fn constructor(&mut self, p1: bool) {
            self.called = true;
            self.p = p1;
        }
    }
}

#[test]
fn dispatch_empty_abi() {
    let mut endpoint = contract::EmptyEndpoint::new(contract::EmptyContractInstance {
        called: false,
        p: false,
    });
    endpoint.dispatch_ctor(&[
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x01,
    ]);
    assert!(endpoint.inner.called);
    assert!(endpoint.inner.p);
}

#[test]
fn baz_call() {
    let mut client = Client::new(Address::zero());
    client.baz(69, true);
    let payload = crate::get_call_payload();
    assert_eq!(payload.as_slice(), PAYLOAD_SAMPLE_1);
}
